CODE ----

1. Takes number of items using int(input()).
- input() reads from the user, and int() converts it to an integer.

2. Creates two empty lists:
- weights[] → to store item weights.
- values[] → to store item values (profits).

3. Takes weight and value for each item together on one line using map(int, input().split()).
- split() breaks input by spaces.
- map(int, ...) converts them to integers.

4. Stores input values in weights and values lists using append().

5. Takes knapsack capacity (W) using int(input()).
- This represents the maximum weight the bag can hold.

6. Creates a 2D list (DP table) with size (n+1) × (W+1) initialized with zeros.
- dp[i][w] stores maximum profit for first i items with capacity w.

7. Builds the table bottom-up:
- Two nested loops are used:
--- Outer loop (i) → goes through each item.
--- Inner loop (w) → goes through each capacity value from 1 to W.

8. Checks if the current item can fit in the bag (weights[i-1] <= w):
- If yes → two choices are considered:
          -- Include item: values[i-1] + dp[i-1][w - weights[i-1]]
          -- Exclude item: dp[i-1][w]
- The maximum of these two values is stored in dp[i][w].

9. If item weight is more than capacity (else case):
 - The item cannot be added → keep previous best result (dp[i-1][w]).

10. After filling the table, the last cell dp[n][W] contains the maximum profit possible.

11. Prints the final output:
- "Maximum profit that can be obtained:" dp[n][W]
→ Displays the best achievable value.





EXPLAIN -----
This program solves the 0/1 Knapsack Problem using the Dynamic Programming approach.
The aim is to find the maximum profit that can be earned by selecting items within a given capacity, where each item can be either taken or not taken (no fractions allowed).

The user enters the number of items, their weights and values, and the knapsack capacity.
A 2D table (dp) is created where dp[i][w] stores the maximum profit possible using the first i items for capacity w.
For each item, the program checks:

- If the item’s weight ≤ current capacity, it decides whether to include or exclude it using the formula:
dp[i][w] = max(value[i-1] + dp[i-1][w - weight[i-1]], dp[i-1][w])
- Otherwise, the item is skipped: dp[i][w] = dp[i-1][w].

After filling the table, the last cell dp[n][W] gives the maximum profit.
For the given input (weights: 10, 20, 30; values: 60, 110, 150; capacity: 50), the best combination is taking items 2 and 3 → total profit = 260.

Time Complexity: O(n × W)
Space Complexity: O(n × W)



OUTPUT - 
Step-by-step output logic: 
If we take Item 1 (10, 60) and Item 2 (20, 110) → total weight = 30, total value = 170
If we take Item 2 (20, 110) and Item 3 (30, 150) → total weight = 50, total value = 260 
If we take Item 1 and Item 3 → total weight = 40, total value = 210